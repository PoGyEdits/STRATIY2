<!doctype html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kick Sub Goal Frame</title>
  <style>
    :root {
      --frame-width: 420;
      --frame-height: 315;
      --stroke-width: 16;
      --radius: 0;
      --label-offset: 96;
      --track: transparent;
      --accent-a: #ff8a00;
      --accent-b: #ffb347;
      --text: #f8fafc;
      --text-shadow: rgba(0, 0, 0, 0.8);
      --font: "Segoe UI", Tahoma, sans-serif;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: transparent;
      overflow: hidden;
      font-family: var(--font);
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }

    .frame-shell {
      position: relative;
      width: calc(var(--frame-width) * 1px);
      height: calc(var(--frame-height) * 1px);
      filter: drop-shadow(0 0 12px rgba(0, 0, 0, 0.5));
    }

    .frame-svg {
      width: 100%;
      height: 100%;
      overflow: visible;
    }

    .status {
      position: absolute;
      left: 50%;
      bottom: calc(-1px * var(--label-offset));
      transform: translateX(-50%);
      min-width: 220px;
      text-align: center;
      color: var(--text);
      text-shadow: 0 2px 8px var(--text-shadow);
      padding: 8px 12px;
      border-radius: 0;
      background: rgba(14, 17, 23, 0.82);
      border: 1px solid rgba(255, 138, 0, 0.35);
      backdrop-filter: blur(3px);
    }

    .status .title {
      font-size: 14px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      opacity: 0.9;
    }

    .status .count {
      margin-top: 3px;
      font-size: 26px;
      font-weight: 800;
      line-height: 1;
    }

    .status .sub {
      margin-top: 6px;
      font-size: 13px;
      opacity: 0.95;
    }

    .status.error {
      background: rgba(120, 20, 20, 0.55);
    }
  </style>
</head>
<body>
  <div class="overlay">
    <div class="frame-shell">
      <svg id="frameSvg" class="frame-svg" viewBox="0 0 100 100" aria-hidden="true">
        <defs>
          <linearGradient id="progressGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="var(--accent-a)" />
            <stop offset="100%" stop-color="var(--accent-b)" />
          </linearGradient>
        </defs>
        <rect id="trackRect" x="8" y="8" width="84" height="84" rx="7" ry="7" fill="none" stroke="var(--track)" stroke-width="4" />
        <rect id="progressRect" x="8" y="8" width="84" height="84" rx="7" ry="7" fill="none" stroke="url(#progressGradient)" stroke-width="4" stroke-linecap="butt" transform="rotate(-90 50 50)" />
      </svg>

      <div id="status" class="status">
        <div id="title" class="title">Kick Sub Goal</div>
        <div id="count" class="count">0 / 25</div>
        <div id="sub" class="sub">Zbývá 25 subů</div>
      </div>
    </div>
  </div>

  <script>
    const params = new URLSearchParams(window.location.search);

    const cfg = {
      channel: (params.get("channel") || "Straty").trim(),
      goal: Math.max(1, Number(params.get("goal") || 25)),
      title: params.get("title") || "Kick Sub Goal",
      refreshMs: Math.max(5000, Number(params.get("refreshMs") || 30000)),
      frameWidth: Math.max(220, Number(params.get("w") || params.get("size") || 420)),
      frameHeight: Math.max(140, Number(params.get("h") || 315)),
      stroke: Math.max(4, Number(params.get("stroke") || 16)),
      radius: Math.max(0, Number(params.get("radius") || 16)),
      labelOffset: Math.max(70, Number(params.get("labelOffset") || 104)),
      manualSubs: params.has("subs") ? Math.max(0, Number(params.get("subs"))) : null,
      manualRemaining: params.has("remaining") ? Math.max(0, Number(params.get("remaining"))) : null,
      apiBase: (params.get("api") || "/api/subgoal").trim(),
      chatroomApi: (params.get("chatApi") || "/api/chatroom").trim(),
      chatroomId: params.has("chatroomId") ? Math.max(1, Number(params.get("chatroomId"))) : null,
      live: params.get("live") !== "0"
    };

    document.documentElement.style.setProperty("--frame-width", cfg.frameWidth);
    document.documentElement.style.setProperty("--frame-height", cfg.frameHeight);
    document.documentElement.style.setProperty("--stroke-width", cfg.stroke);
    document.documentElement.style.setProperty("--radius", cfg.radius);
    document.documentElement.style.setProperty("--label-offset", cfg.labelOffset);

    const titleEl = document.getElementById("title");
    const countEl = document.getElementById("count");
    const subEl = document.getElementById("sub");
    const statusEl = document.getElementById("status");
    const trackRect = document.getElementById("trackRect");
    const progressRect = document.getElementById("progressRect");

    titleEl.textContent = cfg.title;

    const frameSvg = document.getElementById("frameSvg");
    frameSvg.setAttribute("viewBox", `0 0 ${cfg.frameWidth} ${cfg.frameHeight}`);
    const inset = cfg.stroke * 0.5;
    progressRect.setAttribute("transform", `rotate(-90 ${cfg.frameWidth / 2} ${cfg.frameHeight / 2})`);
    const rectW = Math.max(1, cfg.frameWidth - cfg.stroke);
    const rectH = Math.max(1, cfg.frameHeight - cfg.stroke);
    const corner = Math.min(cfg.radius, rectW / 2, rectH / 2);

    trackRect.style.display = "none";
    progressRect.setAttribute("x", inset.toString());
    progressRect.setAttribute("y", inset.toString());
    progressRect.setAttribute("width", rectW.toString());
    progressRect.setAttribute("height", rectH.toString());
    progressRect.setAttribute("rx", corner.toString());
    progressRect.setAttribute("ry", corner.toString());
    progressRect.setAttribute("stroke-width", cfg.stroke.toString());

    const perimeter = 2 * (rectW + rectH) - 8 * corner + 2 * Math.PI * corner;
    progressRect.style.strokeDasharray = `${perimeter}`;

    let lastRatio = 0;
    let liveGoal = cfg.goal;
    let liveCurrent = 0;
    let ws = null;

    function drawProgress(current, goalOverride = null, remainingOverride = null) {
      if (Number.isFinite(goalOverride) && goalOverride > 0) {
        liveGoal = Math.max(1, Math.floor(goalOverride));
      }
      const clampedCurrent = Math.max(0, Number.isFinite(current) ? current : 0);
      const ratio = Math.min(1, clampedCurrent / liveGoal);
      const offset = perimeter * (1 - ratio);

      progressRect.style.transition = "stroke-dashoffset 800ms ease";
      progressRect.style.strokeDashoffset = `${offset}`;
      if (ratio < lastRatio) {
        progressRect.style.transition = "stroke-dashoffset 350ms ease-out";
      }
      lastRatio = ratio;

      const missing = Number.isFinite(remainingOverride) ? Math.max(0, Math.floor(remainingOverride)) : Math.max(0, liveGoal - clampedCurrent);
      countEl.textContent = `${clampedCurrent} / ${liveGoal}`;
      subEl.textContent = missing === 0 ? "Goal splněn" : `Zbývá ${missing} subů`;
      statusEl.classList.remove("error");
      liveCurrent = clampedCurrent;
    }

    function buildApiUrl() {
      const apiUrl = new URL(cfg.apiBase, window.location.href);
      apiUrl.searchParams.set("channel", cfg.channel);
      apiUrl.searchParams.set("goal", String(cfg.goal));
      return apiUrl.toString();
    }

    async function loadSubs() {
      if (cfg.manualSubs !== null && Number.isFinite(cfg.manualSubs)) {
        drawProgress(cfg.manualSubs);
        return;
      }
      if (cfg.manualRemaining !== null && Number.isFinite(cfg.manualRemaining)) {
        drawProgress(Math.max(0, cfg.goal - cfg.manualRemaining), cfg.goal, cfg.manualRemaining);
        return;
      }

      try {
        const res = await fetch(buildApiUrl(), { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        if (!data || !Number.isFinite(data.current)) throw new Error("Invalid API payload");

        drawProgress(data.current, data.goal, data.remaining);
      } catch (err) {
        statusEl.classList.add("error");
        subEl.textContent = "Auto nacteni selhalo. Docasne pouzij ?subs=177";
        console.warn("Sub goal API failed:", err);
      }
    }

    function parseWsEvent(raw) {
      try {
        const msg = JSON.parse(raw);
        if (!msg || typeof msg !== "object") return null;
        return msg;
      } catch {
        return null;
      }
    }

    function parseEventData(dataField) {
      if (!dataField) return null;
      if (typeof dataField === "object") return dataField;
      if (typeof dataField !== "string") return null;
      try {
        return JSON.parse(dataField);
      } catch {
        return null;
      }
    }

    async function getChatroomId() {
      if (Number.isFinite(cfg.chatroomId) && cfg.chatroomId > 0) return cfg.chatroomId;
      const chatApiUrl = new URL(cfg.chatroomApi, window.location.href);
      chatApiUrl.searchParams.set("channel", cfg.channel);
      const res = await fetch(chatApiUrl.toString(), { cache: "no-store" });
      if (!res.ok) throw new Error(`chatroom HTTP ${res.status}`);
      const data = await res.json();
      if (!data || !Number.isFinite(Number(data.chatroomId))) throw new Error("Missing chatroomId");
      return Number(data.chatroomId);
    }

    function connectLive(chatroomId) {
      if (!cfg.live || !Number.isFinite(chatroomId) || chatroomId <= 0) return;
      const url = "wss://ws-us2.pusher.com/app/32cbd69e4b950bf97679?protocol=7&client=js&version=7.6.0&flash=false";
      ws = new WebSocket(url);

      ws.addEventListener("open", () => {
        const payload = {
          event: "pusher:subscribe",
          data: {
            auth: "",
            channel: `chatrooms.${chatroomId}.v2`
          }
        };
        ws.send(JSON.stringify(payload));
      });

      ws.addEventListener("message", (evt) => {
        const msg = parseWsEvent(evt.data);
        if (!msg) return;

        if (msg.event === "pusher:ping") {
          ws.send(JSON.stringify({ event: "pusher:pong", data: {} }));
          return;
        }

        if (msg.event === "App\\Events\\SubscriptionEvent") {
          drawProgress(liveCurrent + 1);
          return;
        }

        if (msg.event === "App\\Events\\GiftedSubscriptionsEvent") {
          const data = parseEventData(msg.data);
          const giftedUsers = data && Array.isArray(data.gifted_usernames) ? data.gifted_usernames.length : null;
          const qty = Number.isFinite(giftedUsers) && giftedUsers > 0 ? giftedUsers : 1;
          drawProgress(liveCurrent + qty);
        }
      });

      ws.addEventListener("close", () => {
        setTimeout(() => {
          connectLive(chatroomId);
        }, 3500);
      });

      ws.addEventListener("error", () => {
        statusEl.classList.remove("error");
      });
    }

    drawProgress(0);
    loadSubs().finally(async () => {
      if (!cfg.live) return;
      try {
        const id = await getChatroomId();
        connectLive(id);
      } catch (err) {
        console.warn("Live chat connect failed:", err);
      }
    });
    setInterval(loadSubs, cfg.refreshMs);
  </script>
</body>
</html>
