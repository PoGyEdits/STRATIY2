<!doctype html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kick Sub Goal Frame</title>
  <style>
    :root {
      --frame-width: 420;
      --frame-height: 420;
      --stroke-width: 16;
      --radius: 0;
      --label-offset: 96;
      --frame-pad: 14;
      --track: rgba(255, 138, 0, 0.35);
      --accent-a: #ff8a00;
      --accent-b: #ffb347;
      --text: #f8fafc;
      --text-shadow: rgba(0, 0, 0, 0.8);
      --font: "Segoe UI", Tahoma, sans-serif;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: transparent;
      overflow: hidden;
      font-family: var(--font);
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }

    .frame-shell {
      position: relative;
      width: calc((var(--frame-width) + var(--frame-pad) * 2) * 1px);
      height: calc((var(--frame-height) + var(--frame-pad) * 2) * 1px);
      filter: drop-shadow(0 0 12px rgba(0, 0, 0, 0.5));
    }

    .frame-svg {
      width: 100%;
      height: 100%;
      overflow: visible;
    }

    .status {
      position: absolute;
      left: 50%;
      bottom: calc(-1px * var(--label-offset));
      transform: translateX(-50%);
      min-width: 220px;
      text-align: center;
      color: var(--text);
      text-shadow: 0 2px 8px var(--text-shadow);
      padding: 8px 12px;
      border-radius: 0;
      background: rgba(14, 17, 23, 0.82);
      border: 1px solid rgba(255, 138, 0, 0.35);
      backdrop-filter: blur(3px);
    }

    .status .title {
      font-size: 14px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      opacity: 0.9;
    }

    .status .count {
      margin-top: 3px;
      font-size: 26px;
      font-weight: 800;
      line-height: 1;
    }

    .status .sub {
      margin-top: 6px;
      font-size: 13px;
      opacity: 0.95;
    }

    .status.error {
      background: rgba(120, 20, 20, 0.55);
    }
  </style>
</head>
<body>
  <div class="overlay">
    <div class="frame-shell">
      <svg id="frameSvg" class="frame-svg" viewBox="0 0 100 100" aria-hidden="true">
        <defs>
          <linearGradient id="progressGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="var(--accent-a)" />
            <stop offset="100%" stop-color="var(--accent-b)" />
          </linearGradient>
        </defs>
        <path id="trackRect" d="" fill="none" stroke="var(--track)" stroke-width="4" stroke-linecap="butt" stroke-linejoin="miter" />
        <path id="progressRect" d="" fill="none" stroke="url(#progressGradient)" stroke-width="4" stroke-linecap="butt" stroke-linejoin="miter" />
      </svg>

      <div id="status" class="status">
        <div id="title" class="title">Kick Sub Goal</div>
        <div id="count" class="count">0 / 25</div>
        <div id="sub" class="sub">Zbývá 25 subů</div>
      </div>
    </div>
  </div>

  <script>
    const params = new URLSearchParams(window.location.search);

    const cfg = {
      channel: (params.get("channel") || "Straty").trim(),
      goal: Math.max(1, Number(params.get("goal") || 25)),
      title: params.get("title") || "Kick Sub Goal",
      refreshMs: Math.max(5000, Number(params.get("refreshMs") || 30000)),
      frameWidth: Math.max(220, Number(params.get("w") || params.get("size") || 420)),
      frameHeight: Math.max(220, Number(params.get("h") || params.get("w") || params.get("size") || 420)),
      stroke: Math.max(4, Number(params.get("stroke") || 16)),
      radius: 0,
      pad: Math.max(0, Number(params.get("pad") || 14)),
      labelOffset: Math.max(70, Number(params.get("labelOffset") || 104)),
      bannerScale: Math.max(0.6, Math.min(2, Number(params.get("bannerScale") || 1))),
      showBanner: params.get("banner") !== "0",
      color1: params.get("color1") || null,
      color2: params.get("color2") || null,
      trackColor: params.get("trackColor") || null,
      panelColor: params.get("panelColor") || null,
      textColor: params.get("textColor") || null,
      borderColor: params.get("borderColor") || null,
      manualSubs: params.has("subs") ? Math.max(0, Number(params.get("subs"))) : null,
      manualRemaining: params.has("remaining") ? Math.max(0, Number(params.get("remaining"))) : null,
      apiBase: (params.get("api") || "/api/subgoal").trim(),
      chatroomApi: (params.get("chatApi") || "/api/chatroom").trim(),
      chatroomId: params.has("chatroomId") ? Math.max(1, Number(params.get("chatroomId"))) : null,
      live: params.get("live") !== "0"
    };

    function cssColorOrNull(v) {
      if (!v || typeof v !== "string") return null;
      const s = v.trim();
      if (/^#[0-9a-fA-F]{3,8}$/.test(s)) return s;
      if (/^(rgb|rgba|hsl|hsla)\(/i.test(s)) return s;
      return null;
    }

    document.documentElement.style.setProperty("--frame-width", cfg.frameWidth);
    document.documentElement.style.setProperty("--frame-height", cfg.frameHeight);
    document.documentElement.style.setProperty("--stroke-width", cfg.stroke);
    document.documentElement.style.setProperty("--radius", cfg.radius);
    document.documentElement.style.setProperty("--frame-pad", cfg.pad);
    document.documentElement.style.setProperty("--label-offset", cfg.labelOffset);
    const c1 = cssColorOrNull(cfg.color1);
    const c2 = cssColorOrNull(cfg.color2);
    const tr = cssColorOrNull(cfg.trackColor);
    const pc = cssColorOrNull(cfg.panelColor);
    const tc = cssColorOrNull(cfg.textColor);
    const bc = cssColorOrNull(cfg.borderColor);
    if (c1) document.documentElement.style.setProperty("--accent-a", c1);
    if (c2) document.documentElement.style.setProperty("--accent-b", c2);
    if (tr) document.documentElement.style.setProperty("--track", tr);

    const titleEl = document.getElementById("title");
    const countEl = document.getElementById("count");
    const subEl = document.getElementById("sub");
    const statusEl = document.getElementById("status");
    const trackRect = document.getElementById("trackRect");
    const progressRect = document.getElementById("progressRect");
    if (pc) statusEl.style.background = pc;
    if (tc) statusEl.style.color = tc;
    if (bc) statusEl.style.borderColor = bc;

    titleEl.textContent = cfg.title;
    statusEl.style.transform = `translateX(-50%) scale(${cfg.bannerScale})`;
    statusEl.style.transformOrigin = "center top";
    if (!cfg.showBanner) {
      statusEl.style.display = "none";
    }

    const frameSvg = document.getElementById("frameSvg");
    const outerW = cfg.frameWidth + cfg.pad * 2;
    const outerH = cfg.frameHeight + cfg.pad * 2;
    frameSvg.setAttribute("viewBox", `0 0 ${outerW} ${outerH}`);
    const inset = cfg.pad + cfg.stroke * 0.5;
    const rectW = Math.max(1, cfg.frameWidth - cfg.stroke);
    const rectH = Math.max(1, cfg.frameHeight - cfg.stroke);
    const x1 = inset;
    const y1 = inset;
    const x2 = inset + rectW;
    const y2 = inset + rectH;
    const framePath = `M ${x1} ${y1} H ${x2} V ${y2} H ${x1} V ${y1}`;

    trackRect.style.display = "block";
    trackRect.setAttribute("d", framePath);
    trackRect.setAttribute("stroke-width", cfg.stroke.toString());
    progressRect.setAttribute("d", framePath);
    progressRect.setAttribute("stroke-width", cfg.stroke.toString());

    progressRect.setAttribute("pathLength", "100");

    let lastRatio = 0;
    let liveGoal = cfg.goal;
    let liveCurrent = 0;
    let ws = null;

    function drawProgress(current, goalOverride = null, remainingOverride = null) {
      if (Number.isFinite(goalOverride) && goalOverride > 0) {
        liveGoal = Math.max(1, Math.floor(goalOverride));
      }
      const clampedCurrent = Math.max(0, Number.isFinite(current) ? current : 0);
      const ratio = Math.min(1, clampedCurrent / liveGoal);
      const dash = Math.max(0, Math.min(100, ratio * 100));
      progressRect.style.transition = "stroke-dasharray 800ms ease";
      progressRect.style.strokeDasharray = `${dash} 100`;
      if (ratio < lastRatio) {
        progressRect.style.transition = "stroke-dasharray 350ms ease-out";
      }
      lastRatio = ratio;

      const missing = Number.isFinite(remainingOverride) ? Math.max(0, Math.floor(remainingOverride)) : Math.max(0, liveGoal - clampedCurrent);
      countEl.textContent = `${clampedCurrent} / ${liveGoal}`;
      subEl.textContent = missing === 0 ? "Goal splněn" : `Zbývá ${missing} subů`;
      statusEl.classList.remove("error");
      liveCurrent = clampedCurrent;
    }

    function buildApiUrl() {
      const apiUrl = new URL(cfg.apiBase, window.location.href);
      apiUrl.searchParams.set("channel", cfg.channel);
      apiUrl.searchParams.set("goal", String(cfg.goal));
      return apiUrl.toString();
    }

    async function loadSubs() {
      if (cfg.manualSubs !== null && Number.isFinite(cfg.manualSubs)) {
        drawProgress(cfg.manualSubs);
        return;
      }
      if (cfg.manualRemaining !== null && Number.isFinite(cfg.manualRemaining)) {
        drawProgress(Math.max(0, cfg.goal - cfg.manualRemaining), cfg.goal, cfg.manualRemaining);
        return;
      }

      try {
        const res = await fetch(buildApiUrl(), { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        if (!data || !Number.isFinite(data.current)) throw new Error("Invalid API payload");

        drawProgress(data.current, data.goal, data.remaining);
      } catch (err) {
        statusEl.classList.add("error");
        subEl.textContent = "Auto nacteni selhalo. Docasne pouzij ?subs=177";
        console.warn("Sub goal API failed:", err);
      }
    }

    function parseWsEvent(raw) {
      try {
        const msg = JSON.parse(raw);
        if (!msg || typeof msg !== "object") return null;
        return msg;
      } catch {
        return null;
      }
    }

    function parseEventData(dataField) {
      if (!dataField) return null;
      if (typeof dataField === "object") return dataField;
      if (typeof dataField !== "string") return null;
      try {
        return JSON.parse(dataField);
      } catch {
        return null;
      }
    }

    async function getChatroomId() {
      if (Number.isFinite(cfg.chatroomId) && cfg.chatroomId > 0) return cfg.chatroomId;
      const chatApiUrl = new URL(cfg.chatroomApi, window.location.href);
      chatApiUrl.searchParams.set("channel", cfg.channel);
      const res = await fetch(chatApiUrl.toString(), { cache: "no-store" });
      if (!res.ok) throw new Error(`chatroom HTTP ${res.status}`);
      const data = await res.json();
      if (!data || !Number.isFinite(Number(data.chatroomId))) throw new Error("Missing chatroomId");
      return Number(data.chatroomId);
    }

    function connectLive(chatroomId) {
      if (!cfg.live || !Number.isFinite(chatroomId) || chatroomId <= 0) return;
      const url = "wss://ws-us2.pusher.com/app/32cbd69e4b950bf97679?protocol=7&client=js&version=7.6.0&flash=false";
      ws = new WebSocket(url);

      ws.addEventListener("open", () => {
        const payload = {
          event: "pusher:subscribe",
          data: {
            auth: "",
            channel: `chatrooms.${chatroomId}.v2`
          }
        };
        ws.send(JSON.stringify(payload));
      });

      ws.addEventListener("message", (evt) => {
        const msg = parseWsEvent(evt.data);
        if (!msg) return;

        if (msg.event === "pusher:ping") {
          ws.send(JSON.stringify({ event: "pusher:pong", data: {} }));
          return;
        }

        if (msg.event === "App\\Events\\SubscriptionEvent") {
          drawProgress(liveCurrent + 1);
          return;
        }

        if (msg.event === "App\\Events\\GiftedSubscriptionsEvent") {
          const data = parseEventData(msg.data);
          const giftedUsers = data && Array.isArray(data.gifted_usernames) ? data.gifted_usernames.length : null;
          const qty = Number.isFinite(giftedUsers) && giftedUsers > 0 ? giftedUsers : 1;
          drawProgress(liveCurrent + qty);
        }
      });

      ws.addEventListener("close", () => {
        setTimeout(() => {
          connectLive(chatroomId);
        }, 3500);
      });

      ws.addEventListener("error", () => {
        statusEl.classList.remove("error");
      });
    }

    drawProgress(0);
    loadSubs().finally(async () => {
      if (!cfg.live) return;
      try {
        const id = await getChatroomId();
        connectLive(id);
      } catch (err) {
        console.warn("Live chat connect failed:", err);
      }
    });
    setInterval(loadSubs, cfg.refreshMs);
  </script>
</body>
</html>
